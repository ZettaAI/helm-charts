# add a service and deployment for testing
whoami: false


# these are converted to configmaps and added to pods as env vars
# configmaps are named <chart_name>-<env_group_name> (eg: common)
# added to all deployments/pods so they must be common
# for deployment specific add them to deployment.env
env: []
# - name: common
#   vars: 
#     SHELL: /bin/bash


# file names of secret keys for cloudvolume
# these will be mounted as volumes
# eg: if a file name is secret.json
# volume.name: secret, subPath: secret.json
# mountPath: /root/.cloudvolume/secrets
# NOTE: this assumes kubernetes secrets are already present.
# this limitation is because Helm does not support
# loading files external to a chart for security reasons.
cloudVolumeSecrets: []


readService:
  enabled: &readServiceEnabled false
  name: &readServiceName "chunkedgraph-read"
  annotations: {}
  type: ClusterIP
  port: 80
  targetPort: &readPort 81
  portName: web
  protocol: TCP
readDeployment:
  enabled: *readServiceEnabled
  name: *readServiceName
  nodeSelector: {}
  annotations: {}
  startServer: true
  image:
    repository: null
    tag: null
    pullPolicy: Always
  env:
    - name: "app-server"
      vars:
        GRAPH_SERVER_PORT: *readPort
        GRAPH_SERVER_WORKERS: 3
  replicaCount: 1
  ports:
    - name: http
      protocol: TCP
      containerPort: *readPort
  resources:
    requests:
      cpu: 450m
      memory: 1.5G
  hpa:
    enabled: false
    minReplicas: 3
    maxReplicas: 30
    targetMem: 85
    targetCPU: 95


editService:
  enabled: &editServiceEnabled false
  name: &editServiceName "chunkedgraph-edit"
  annotations: {}
  type: ClusterIP
  port: 80
  targetPort: &editPort 82
  portName: web
  protocol: TCP
editDeployment:
  enabled: *editServiceEnabled
  name: *editServiceName
  nodeSelector: {}
  annotations: {}
  startServer: true
  image:
    repository: null
    tag: null
    pullPolicy: Always
  env:
    - name: "app-server"
      vars:
        GRAPH_SERVER_PORT: *editPort
        GRAPH_SERVER_WORKERS: 2
        REMESH_SERVICE: "http://chunkedgraph-remesh"
  replicaCount: 1
  ports:
    - name: http
      protocol: TCP
      containerPort: *editPort
  resources:
    requests:
      cpu: 600m
      memory: 2G
  hpa:
    enabled: false
    minReplicas: 2
    maxReplicas: 10
    targetMem: 85
    targetCPU: 85


meshService:
  enabled: &meshServiceEnabled false
  name: &meshServiceName "chunkedgraph-mesh"
  annotations: {}
  type: ClusterIP
  port: 80
  targetPort: &meshPort 83
  portName: web
  protocol: TCP
meshDeployment:
  enabled: *meshServiceEnabled
  name: *meshServiceName
  nodeSelector: {}
  annotations: {}
  startServer: true
  image:
    repository: null
    tag: null
    pullPolicy: Always
  env:
    - name: "app-server"
      vars:
        GRAPH_SERVER_PORT: *meshPort
        GRAPH_SERVER_WORKERS: 3
  replicaCount: 1
  ports:
    - name: http
      protocol: TCP
      containerPort: *meshPort
  resources:
    requests:
      cpu: 450m
      memory: 1.5G
  hpa:
    enabled: false
    minReplicas: 3
    maxReplicas: 15
    targetMem: 90
    targetCPU: 95


remeshService:
  enabled: &remeshServiceEnabled false
  name: &remeshServiceName "chunkedgraph-remesh"
  annotations: {}
  type: ClusterIP
  port: 80
  targetPort: &remeshPort 84
  portName: web
  protocol: TCP
remeshDeployment:
  enabled: *remeshServiceEnabled
  name: *remeshServiceName
  nodeSelector: {}
  annotations: {}
  startServer: true
  image:
    repository: null
    tag: null
    pullPolicy: Always
  env:
    - name: "app-server"
      vars:
        GRAPH_SERVER_PORT: *remeshPort
        GRAPH_SERVER_WORKERS: 2
  replicaCount: 1
  ports:
    - name: http
      protocol: TCP
      containerPort: *remeshPort
  resources:
    requests:
      cpu: 1
      memory: 4G
  hpa:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    targetMem: 90
    targetCPU: 95
